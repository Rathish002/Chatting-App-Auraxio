import { Plugin, TransformResult as TransformResult$1, ResolveIdResult, LoadResult as LoadResult$1, SourceMap, ResolveIdHook, LoadHook, TransformHook } from 'rollup';
import { Parser } from 'acorn';

declare global {
  interface Window {
    __dependencies?: { [key: string]: any };
    rollup: any;
  }
}

type ApplicationCache = {
  get: (name: string) => any | undefined;
  getAll: () => { [name: string]: any };
  set: (name: string, value: any) => boolean;
  has: (name: string) => boolean;
  update: (name: string, value: any) => boolean;
  delete: (name: string) => boolean;
  clear: () => void;
};

type PackagerOptions = {
  cache: boolean;
  sourcemaps: boolean;
};

type File = {
  name: string;
  path: string;
  code: string;
  entry?: boolean;
};

type PackagerContext = {
  acornParser?: Parser["parse"];
  dependencies: ApplicationCache;
  transpilers: ApplicationCache;
  workerQueue: WorkerQueue;
  files: File[];
  bundleOptions: BundleOptions;
  plugins: PluginContext[];
};

type BundleOptions = {
  dependencies: { [moduleName: string]: string };
};

interface Transformer extends Plugin {}
interface Resolver extends Plugin {}
interface Loader extends Plugin {}
interface Setup extends Plugin {}
type TransformResult = TransformResult$1;
type ResolveResult = ResolveIdResult;
type LoadResult = LoadResult$1;

type ParsedPackagePath = {
  name: string | null;
  version: string | null;
  path: string | null;
};

type PluginResolverResult =
  | { id: string; syntheticNamedExports?: boolean | null }
  | string
  | null
  | void;
type PluginResolverHook = (
  this: PluginContext,
  moduleId: string,
  parentId?: string
) => Promise<PluginResolverResult> | PluginResolverResult;

type PluginLoaderResult =
  | {
      code: string;
      map?: string | SourceMap;
      syntheticNamedExports?: boolean | null;
    }
  | string
  | null
  | void;
type PluginLoaderHook = (
  this: PluginContext,
  moduleId: string
) => Promise<PluginLoaderResult> | PluginLoaderResult;

type PluginBeforeBundleHookResult = string | null | void;
type PluginBeforeBundleHook = (
  this: PluginContext,
  code: string,
  moduleId: string
) => Promise<PluginBeforeBundleHookResult> | PluginBeforeBundleHookResult;

type PluginHook =
  | PluginResolverHook
  | PluginLoaderHook
  | PluginBeforeBundleHook;

type PluginTranspiler = {
  worker: () => Worker;
  dependencies?: string[];
};

type PluginAPI = {
  name: string;
  transpiler?: PluginTranspiler;
  resolver?: PluginResolverHook;
  loader?: PluginLoaderHook;
  beforeBundle?: PluginBeforeBundleHook;
  extensions?: string[];
};

type PluginContextMeta = Map<string, any>;

type PluginContext = {
  name: string;
  packagerContext: PackagerContext;
  rawPlugin: PluginAPI;
  meta: PluginContextMeta;
};

type TranspilerContext = {
  context: PluginContext;
  worker: Worker;
  extensions: string[];
  dependencyTranspilers?: string[];
  transpile: (file: File) => Promise<any>;
  setContext: (context: PluginContext) => void;
  getDependencyTranspiler: (extension: string) => TranspilerContext | null;
  transpileAdditional: (data: any) => Promise<any>;
};

type PluginAPIasRollupPlugin = {
  name: string;
  resolveId?: ResolveIdHook;
  load?: LoadHook;
  transform?: TransformHook;
};

type PluginManagerPlugin = PluginAPI & { transformed: boolean };

type PluginManager = {
  packagerContext: PackagerContext;
  setPackagerContext: (context: PackagerContext) => void;
  registerPlugin: (plugin: PluginAPI) => void;
  prepareAndGetPlugins: () => PluginManagerPlugin[];
  getRegisteredPlugins: () => PluginManagerPlugin[];
};

declare function createPlugin(options: PluginAPI): PluginAPI;
declare function createTranspiler(
  this: TranspilerContext,
  options: PluginTranspiler,
  context: PluginContext
): TranspilerContext;

declare enum TRANSPILE_STATUS {
  PREPARE_FILES = "TRANSPILER:FILE:PREPARE",
  PREPARE_ADDITIONAL = "TRANSPILER:ADDITIONAL:PREPARE",
  ADDITIONAL_TRANSPILED = "TRANSPILER:ADDITIONAL:TRANSPILED",
  TRANSPILE_COMPLETE = "TRANSPILER:TRANSPILE:COMPLETE",
  ERROR_COMPILE = "TRANSPILER:ERROR:COMPILE",
  ERROR_ADDITIONAL = "TRANSPILER:ERROR:ADDITIONAL"
}

type WorkerQueue = {
  currentTask: any;
  complete: any[];
  errors: any[];
  queue: Function[] | any[];
  awaiters: Function[];
  push: (cb: Function | Promise<any>) => void;
  next: () => void;
  callAWaiters: () => void;
  wait: () => Promise<void>;
};

type PackagerBundleResult = {
  code: string;
};
interface PackagerConstructor {
  bundle: (
    files: File[],
    bundleOptions: BundleOptions
  ) => Promise<PackagerBundleResult | undefined>;
  registerPlugin: (plugin: PluginAPI) => void;
}

interface PackagerInterface {
  new (options: PackagerOptions): PackagerConstructor;
}

export default PackagerInterface;
export { ApplicationCache, BundleOptions, File, LoadResult, Loader, PackagerConstructor, PackagerContext, PackagerInterface, PackagerOptions, ParsedPackagePath, PluginAPI, PluginAPIasRollupPlugin, PluginBeforeBundleHook, PluginBeforeBundleHookResult, PluginContext, PluginContextMeta, PluginHook, PluginLoaderHook, PluginLoaderResult, PluginManager, PluginManagerPlugin, PluginResolverHook, PluginResolverResult, PluginTranspiler, ResolveResult, Resolver, Setup, TRANSPILE_STATUS, TransformResult, Transformer, TranspilerContext, WorkerQueue, createPlugin, createTranspiler };
